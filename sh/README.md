# シェルスクリプト

調べながらでないと書けないのは欠陥では？
~~AI に書いてもらうといいよ。~~

罠が多いしめんどい。
~~Pythonで書くといいよ。~~
Perl もそういう系の用途で作られたし…。
~~なお Python のバージョン間互換性。~~

## 3行で

TODO

## 実行方法

中身は単純なテキストファイルでよいが、実行権限が必要。
新規作成したファイルのデフォルト権限は 644 (rw-r--r--) なので、
読める人なら実行できていいだろうという気持ちで `chmod a+x` (All +eXecute)
するのが普通。多分。

```sh
$ ls -l
-rw-r--r-- README.md
-rwxr-xr-x template.sh

$ chmod a+x template.sh
$ ./template.sh
```

ファイル名は `*.sh` か拡張子なしが慣例。

サーチパス `$PATH` にカレントディレクトリを含めてはいけない。
言われないとそんなことやろうとも考えない気がするが、
多分昔セキュリティアタックが流行ったんだと思う。
パスの通っていない場所にある実行ファイルは絶対パスか相対パスで指定する。
そうすると一番簡単なカレントディレクトリ相対指定 `./script.sh` がテンプレとなる。

exec 系のシステムコールは渡されたパスのファイルがテキストで `#!` から始まる場合、
その後をプログラムとコマンドラインとみなし、
さらに自身のファイルをコマンドラインに連結して実行する。
つまりカーネルランドで処理されているらしい。
ちなみに `#!` は shebang と読むが、由来は諸説、つまり謎になってしまっている。

```sh
#!/bin/sh -x

# こう書くと
# argv
# [0]: /bin/sh
# [1]: -x
# [2]: (this file path)
# と exec されたように実行される
```

スクリプト言語のインタプリタを指定すれば別にシェルスクリプト以外もいける。
が、パス解決が終わった後の絶対パスを書かないといけないので、
例えば python のインストール先が違う環境間に対応できない。

微妙な例

```sh
#!/usr/bin/python3

# /usr/bin/ にないマシンだと動かない
```

なんか Python はググると最もよい感じの shebang が広まっている。

誰かが広めたよい例 (~~なお python3.x 間の互換性~~)

```sh
#!/usr/bin/env python3
```

`env` コマンドは単独で実行すると環境変数をリストしてくれる標準準拠性の高いコマンドだが、
実は

```sh
$ env --help
Usage: env [OPTION]... [-] [NAME=VALUE]... [COMMAND [ARG]...]
Set each NAME to VALUE in the environment and run COMMAND.
```

このように環境変数を設定しながらコマンドを実行してくれるコマンドでもある。
~~どちらが本来の使い方なのかは不明。~~
~~ググラビリティ低すぎ。~~
特に追加の環境変数を設定せずにコマンド名だけ渡せば、
パスの通った場所から検索して実行といういつもはシェルにやってもらっている機能を
使うことができる。

環境変数を一時的に指定してコマンドを実行するのは通常は以下のように
シェルの機能を使ってできる。

```sh
VAR1=VALUE1 VAR2=VALUE2 command arg1 arg2
```

が、今回のようにシェルを介さない場合やシェルが古すぎてこの構文が使えない場合
(最近あるのか不明) に env コマンドは役立つ。

## シェルの種類 (1行目の記述)

1行目から複数選択肢があって迷う。~~欠陥。~~

### Bash

Linux のデフォルトログインシェルで、タブを連打すると色々補完されるリッチなやつ。
スクリプト上で使える追加機能も多い。
なので

* Linux で動けばいいや
* Bash の機能が使いたい

というくらいの気持ちならデフォルトの選択肢としてこれでよいと思う。

```sh
#!/bin/bash
```

みんなこう書いてるからこれでいいと思う。
しかし一応以下の方が適切な気もする。

```sh
#!/usr/bin/env bash
```

しかし誰もこんな書き方してないからいいや
(要出典: 最近はコンテナ環境で事故る人もいる)。
Linux = `/bin/bash` があるシステムということでいいと思う。

### Bourne Shell

* Linux だけではなく Unix (-like) システム全般で通用するスクリプトを書きたい
  ~~というのは淡い夢だがそういう気持ちを表現したい~~ 場合

気分の問題、または現代で本当に強いられるのは FreeBSD や Solaris でも動かしたい時とか？
Mac は Zsh という Bash よりさらに高機能版が入っているらしいが、
みんな `/bin/bash` で書いているのでいい感じに動くようにしてあるので多分大丈夫。

Unix V7 由来の由緒正しいシェル、らしい。~~読めない。~~ボーンシェルと読む。
なお POSIX には準拠しとらんし、もはや存在しない。
`/bin/sh` が由緒正しいパスだが、
由緒正しいシェル…に近い動作をするものへのリンクが張られている。

```sh
#!/bin/sh
```

Linux だと Bash の互換モードが動くらしい。
なお Linux でも Debian だと Dash へのリンクな模様。
POSIX を満たす Bourne Shell の有力な後継で BSD 系で `/bin/sh` によく使われている
Ash の Debian バージョンということ、らしい。
~~豆知識多すぎて長くなるんだよ統一しろ。~~

```sh
$ ls -l /bin/sh
lrwxrwxrwx 1 root root 4 Feb  4  2025 /bin/sh -> dash
```

### おまけ: シェルの確認方法

ログインシェルの確認。
そこから他のシェルを実行した場合など、今使っているものを直接指すわけではない。

```sh
echo $SHELL
```

シェルから `argv[0]` を見れば自分が分かる。変なごみがついていることがあるけど。

```sh
$ echo $0
-bash
```

## シェルの動作オプション

`man bash` とかを一生に一度は読んでおくと人生が豊かになることもあるかもしれない。

* `-v`
  * 実行する行をそのまま表示する。コメント等もそのまま。
* `-x` (`-o xtrace`)
  * 実行するコマンドと引数を表示する。いわゆるトレース。
* `-u`
  * 未定義変数へのアクセスをエラーとする。全員使ってくれ。
* `-e` (`-o errexit`)
  * コマンドが失敗 (0 以外で終了) したらそこで実行を終了する。
  * エラー処理をせず外に例外を全部投げる書き捨てコードが可能。
  * これをつけると普通のスクリプト言語になる感がある。
  * これをつけずに終了コードを無視するのは本当に NG。
  * `if` `while` の中、`&&` `||` の左では失敗しても大丈夫などの逃げ道はある。
* `-o pipefail`
  * `cmda | cmdb` のようなパイプで左側のコマンドが失敗した場合でも、
    右のコマンドが成功を返したら exit code `$?` が 0 になってしまうのを改善する。
  * そもそもデフォルトの動作がエラー処理を握りつぶしている時点でおかしい。
  * ~~Python でも使っておいた方がいいよ。~~
  * SIGPIPE で事故ることもあるようだが、
    ~~シェルスクリプトで複雑なことはしない方がいいよ。~~

わくわく安全シェルスクリプトセット

```sh
#!/bin/bash

# よく見る安全セット
set -euo pipefail
# これの略
# -o pipefail が変なくっつき方してるのが気持ち悪いけどタイプ量に抗うことはできない
set -e -u -o pipefail
# 何も言わずに終了したりエラーを吐いたりすると何をやったのか分からないが、
# 実行しているコマンドを毎回 echo するのも面倒な時は -x を追加
set -euxo pipefail
# パイプ使わないならタイプするの面倒だしこれでもいいのかもしれない
# パイプを使う直前で -o pipefail するスタイル
set -eu
set -eux

# set は普通のコマンドなので好きな場所で設定を変更できる
# + で設定を無効に戻すことができる
set +e

# 実はコマンドラインパラメータでも渡せるのでタイプ量を圧縮可能 (可搬性は謎)
#!/bin/bash -eux
# でも shebang ではパラメータが連結されて1つの文字列にされてしまうので
# -o pipefail の指定がどうやっても不可能…
#!/bin/bash -e -u -x -o pipefail (ERROR!)
# (argv[1] = "-e -u -x -o pipefail" にされてしまう)
# そんな時は env -S オプションを使うとスペースで split してくれる
# man env にも shebang に使ってくださいと書いてある
#!/usr/bin/env -S bash -euo pipefail
# でもこんなんやってる人見たことないし変人扱いされるかも…
```

## Lint (shellcheck)

普通に書くと危険なコードが自然に次々と生まれる欠陥があるため、
Lint Tool の言いなりになっておくのがよい。
VSCode 拡張もある。

```sh
sudo apt install shellcheck
```
